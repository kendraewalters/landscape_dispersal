<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Kendra E. Walters" />

<meta name="date" content="2021-05-23" />

<title>Question_1__characterizing_dispersal</title>

<script src="libs/header-attrs-2.8/header-attrs.js"></script>
<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>
<script src="libs/navigation-1.1/codefolding.js"></script>
<link href="libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Question_1__characterizing_dispersal</h1>
<h4 class="author">Kendra E. Walters</h4>
<h4 class="date">2021-05-23</h4>

</div>


<style type="text/css">
.main-container { max-width: 1000px; margin-left: 0; margin-right: auto; }
img{ max-width:200%; height: auto; }
td, th { padding : 6px }
</style>
<div id="purpose" class="section level1">
<h1>Purpose</h1>
<p>To answer our first overarching question for the landscape dispersal project: Is the rate and composition of microbial dispersal into the soil surface spatially heterogeneous?</p>
<p>Because vegetation appears to be a primary route through which bacteria disperse, we hypothesized that the taxa dispersing and their dispersal rate onto the soil surface will differ between two ecosystems. In fact, we know that bacterial abundance and composition in one grassland and CSS plant litter differs.</p>
<pre class="r"><code>library(knitr)
library(tidyverse)
library(data.table)
library(kableExtra)
require(ggplot2)
require(gridExtra)
library(car)
require(vegan)

knitr::opts_knit$set(root.dir = &quot;../&quot;)

knitr::opts_chunk$set(comment=&quot;&quot;, cache=T, warning = F, message = F, fig.path = &quot;05_output_figures/&quot;)</code></pre>
</div>
<div id="abundance-on-glass-slides" class="section level1">
<h1>Abundance on glass slides</h1>
<p>First, we’ll look at the abundances on the glass slides over time to see if they are acculumulating or at equilibrium.</p>
<pre class="r"><code># Load the data
message(getwd())
flow.data &lt;- load(&quot;03_Processed_data/flow_cytometry_cleaned.rda&quot;)
metadata &lt;- load(&quot;03_Processed_data/metadata_cleaned.rda&quot;)


# Left join fights me unless both columns are the same data type
metadata.together$`Random_#_Flow` &lt;- as.character(metadata.together$`Random_#_Flow`)


# Set up a key to change time point into # of days
days.key &lt;- c(&quot;0&quot; = 0, &quot;1&quot; = 12, &quot;2&quot; = 26, &quot;3&quot; = 47, &quot;4&quot; = 54)


# Clean up our data to just be what we need for this analysis 
cell.counts.use &lt;- cleaned.cell.counts %&gt;% left_join(metadata.together) %&gt;% # combine with metadata using Random_#_Flow
  mutate(Treatment = ifelse(is.na(Treatment), &quot;Death&quot;, Treatment)) %&gt;% # add metadata for T0 samples that weren&#39;t included in the overall metadata file
  mutate(Time_Point = ifelse(is.na(Time_Point), 0, Time_Point)) %&gt;% 
  mutate(Ecosystem = ifelse(grepl(&quot;^g&quot;, `Random_#_Flow`), &quot;Grassland&quot;,
                            ifelse(grepl(&quot;^s&quot;, `Random_#_Flow`), &quot;Shrubland&quot;, Ecosystem))) %&gt;%
  select(number_cells_on_glass_slide_cleaned, Treatment, Ecosystem, Time_Point) %&gt;% # reduce to only columns we need
  filter(Treatment != &quot;Closed&quot;) %&gt;% # remove this negative control (should have been removed prior to this script)
  mutate(Time_as_days = days.key[as.character(Time_Point)]) # make column that lists # of days


# Plot this as a boxplot to give a general sense of what the abundance on the glass slides are doing
ggplot(data = cell.counts.use %&gt;% filter(Treatment == &quot;Open&quot;)) +
  geom_boxplot(aes(x = as.factor(Time_Point), y = number_cells_on_glass_slide_cleaned)) + 
  facet_wrap(vars(Ecosystem))</code></pre>
<p><img src="05_output_figures/boxplot_glass_slide_abundance_by_ecosystem-1.png" width="672" /></p>
</div>
<div id="immigration-rate-calculations-assuming-population-growth" class="section level1">
<h1>Immigration rate calculations assuming population growth</h1>
<p>Okay, seems like the immigration rate is faster than the death rate for the first three timepoints, and then a plateau is potentially being reached. We can model this increase and plateau using the integral of our population “growth” equation (with just immigration and death).</p>
<p>dn/dt = i - d*n(t) where n = abundance on glass slides, i = immigration rate, and d = death rate</p>
<p>So the integral is (when forced to go through the origin): n(t) = i/d * (1 - e^(-d*t))</p>
<pre class="r"><code># plotting our data with our fancy integral equation going through the origin
ggplot(data = cell.counts.use %&gt;% filter(Treatment == &quot;Open&quot;) %&gt;% 
  mutate(Time_as_days= as.integer(Time_as_days)), 
       aes(x = Time_as_days, y = number_cells_on_glass_slide_cleaned)) +
  geom_point() + 
  geom_smooth(method = &quot;nls&quot;, formula = &quot;y ~  (Im / d) * (1 - exp(-d * x))&quot;, se=F, 
              method.args = list(start=c(Im=2e5, d=0.034))) +
  facet_wrap(vars(Ecosystem)) </code></pre>
<p><img src="05_output_figures/scatterplot_abundance_glass_slides_by_ecosystem-1.png" width="672" /></p>
<pre class="r"><code># Separate into our two ecosystems
grass.cells &lt;- cell.counts.use %&gt;% filter(Ecosystem == &quot;Grassland&quot;)
shrub.cells &lt;- cell.counts.use %&gt;% filter(Ecosystem == &quot;Shrubland&quot;)


# Calculating the death rate and immigration rate coefficients
(nls.shrub &lt;- nls(number_cells_on_glass_slide_cleaned ~  Im/d * (1 - exp(-d * Time_as_days)), 
               data = shrub.cells[shrub.cells$Treatment == &quot;Open&quot;, ],
               start = list(Im = 2e5, d = 0.034)) %&gt;% summary) </code></pre>
<pre><code>
Formula: number_cells_on_glass_slide_cleaned ~ Im/d * (1 - exp(-d * Time_as_days))

Parameters:
    Estimate Std. Error t value Pr(&gt;|t|)   
Im 2.002e+04  7.059e+03   2.836  0.00676 **
d  3.097e-02  2.036e-02   1.521  0.13499   
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1

Residual standard error: 243700 on 46 degrees of freedom

Number of iterations to convergence: 6 
Achieved convergence tolerance: 5.734e-06</code></pre>
<pre class="r"><code>(nls.grass &lt;- nls(number_cells_on_glass_slide_cleaned ~  Im/d * (1 - exp(-d * Time_as_days)), 
               data = grass.cells[grass.cells$Treatment == &quot;Open&quot;, ],
               start = list(Im = 2e5, d = 0.034)) %&gt;% summary)</code></pre>
<pre><code>
Formula: number_cells_on_glass_slide_cleaned ~ Im/d * (1 - exp(-d * Time_as_days))

Parameters:
    Estimate Std. Error t value Pr(&gt;|t|)
Im 3.732e+04  2.354e+04   1.586    0.120
d  6.902e-02  5.500e-02   1.255    0.216

Residual standard error: 453700 on 46 degrees of freedom

Number of iterations to convergence: 17 
Achieved convergence tolerance: 8.027e-06</code></pre>
<pre class="r"><code># note: use summary(model) to look at standard error, which is HUGE for the death rate and fairly large for the immigration rate</code></pre>
<p>But we don’t actually need to have the model guess what the death rate is because we measured death rate with our death rate glass slides. So let’s plot that data now and calculate our death rate for the grassland and shrubland.</p>
<pre class="r"><code># Calculating death rate for the grassland death slides
intercept.grass &lt;- grass.cells %&gt;% 
  filter(Treatment == &quot;Death&quot;, 
         Time_as_days == 0) %&gt;% 
  summarize(mean = mean(log(number_cells_on_glass_slide_cleaned))) %&gt;% pull(mean)

r.grass &lt;- lm(I(log(number_cells_on_glass_slide_cleaned) - intercept.grass) ~ Time_as_days + 0, 
               grass.cells %&gt;% filter(Treatment == &quot;Death&quot;)) %&gt;% coef*-1 # THIS IS THE DEATH RATE!! (we do negative because this is actually describing the continuous rate at which cells survive, not the continuous rate at which cells die)
print(paste0(&quot;Continuous death rate for grassland cells is &quot;, round(r.grass, 4), &quot;.&quot;))</code></pre>
<pre><code>[1] &quot;Continuous death rate for grassland cells is 0.0311.&quot;</code></pre>
<pre class="r"><code># Calculating death rate for the grassland death slides
intercept.shrub &lt;- shrub.cells %&gt;% 
  filter(Treatment == &quot;Death&quot;, 
         Time_as_days == 0) %&gt;% 
  summarize(mean = mean(log(number_cells_on_glass_slide_cleaned))) %&gt;% pull(mean)

r.shrub &lt;- lm(I(log(number_cells_on_glass_slide_cleaned) - intercept.shrub) ~ Time_as_days + 0, 
               shrub.cells %&gt;% filter(Treatment == &quot;Death&quot;)) %&gt;% coef*-1 # THIS IS THE DEATH RATE!! (we do negative because this is actually describing the continuous rate at which cells survive, not the continuous rate at which cells die)
print(paste0(&quot;Continuous death rate for shrubland cells is &quot;, round(r.shrub, 4), &quot;.&quot;))</code></pre>
<pre><code>[1] &quot;Continuous death rate for shrubland cells is 0.0237.&quot;</code></pre>
<pre class="r"><code># creating a mini data frame to give our parameters for the linear models (since we are picky about our intercepts here)
lm.parameters.death &lt;- data.frame(&quot;Intercept&quot; = c(intercept.grass, intercept.shrub), 
                                  &quot;Slope&quot; = c(r.grass[[1]], r.shrub[[1]]), 
                                  &quot;Ecosystem&quot; = c(&quot;Grassland&quot;, &quot;Shrubland&quot;))


# plotting our death rate data
ggplot(data = cell.counts.use %&gt;% filter(Treatment == &quot;Death&quot;) %&gt;% 
  mutate(Time_as_days= as.integer(Time_as_days)), 
       aes(x = Time_as_days, y = log(number_cells_on_glass_slide_cleaned))) +
  geom_point() + 
  geom_abline(data = lm.parameters.death, aes(intercept = Intercept, slope = -Slope)) + 
  facet_wrap(vars(Ecosystem))</code></pre>
<p><img src="05_output_figures/scatterplot_death_rate_by_ecosystem-1.png" width="672" /></p>
<p>Sweet! Now we can use these death rates to input into our model so we are only asking it to find the estimate for the immigration rate. Note how much smaller the standard errors are for these immigration rates!</p>
<pre class="r"><code># Calculating the death rate and immigration rate coefficients WITH measured death rates
(nls.shrub &lt;- nls(number_cells_on_glass_slide_cleaned ~  
                    Im/0.02372169 * (1 - exp(-0.02372169 * Time_as_days)), 
               data = shrub.cells[shrub.cells$Treatment == &quot;Open&quot;, ],
               start = list(Im = 2e5)) %&gt;% summary) </code></pre>
<pre><code>
Formula: number_cells_on_glass_slide_cleaned ~ Im/0.02372169 * (1 - exp(-0.02372169 * 
    Time_as_days))

Parameters:
   Estimate Std. Error t value Pr(&gt;|t|)    
Im    17625       1477   11.93 7.89e-16 ***
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1

Residual standard error: 241300 on 47 degrees of freedom

Number of iterations to convergence: 1 
Achieved convergence tolerance: 7.677e-08</code></pre>
<pre class="r"><code>(nls.grass &lt;- nls(number_cells_on_glass_slide_cleaned ~ 
                    Im/0.03106574 * (1 - exp(-0.03106574 * Time_as_days)), 
               data = grass.cells[grass.cells$Treatment == &quot;Open&quot;, ],
               start = list(Im = 2e5)) %&gt;% summary)</code></pre>
<pre><code>
Formula: number_cells_on_glass_slide_cleaned ~ Im/0.03106574 * (1 - exp(-0.03106574 * 
    Time_as_days))

Parameters:
   Estimate Std. Error t value Pr(&gt;|t|)    
Im    21918       3170   6.915  1.1e-08 ***
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1

Residual standard error: 454700 on 47 degrees of freedom

Number of iterations to convergence: 1 
Achieved convergence tolerance: 2.33e-08</code></pre>
<pre class="r"><code># Graph the new curves that we made
A &lt;- ggplot(data = grass.cells %&gt;% filter(Treatment == &quot;Open&quot;) %&gt;% 
  mutate(Time_as_days= as.integer(Time_as_days)), 
       aes(x = Time_as_days, y = number_cells_on_glass_slide_cleaned)) +
  geom_point() + 
  geom_smooth(method = &quot;nls&quot;, formula = &quot;y ~  (Im / 0.03106574) * (1 - exp(-0.03106574 * x))&quot;, se=F, 
              method.args = list(start=c(Im=2e5))) +
  ggtitle(&quot;Grassland&quot;)

B &lt;- ggplot(data = shrub.cells %&gt;% filter(Treatment == &quot;Open&quot;) %&gt;% 
  mutate(Time_as_days= as.integer(Time_as_days)), 
       aes(x = Time_as_days, y = number_cells_on_glass_slide_cleaned)) +
  geom_point() + 
  geom_smooth(method = &quot;nls&quot;, formula = &quot;y ~  (Im / 0.02372169) * (1 - exp(-0.02372169 * x))&quot;, se=F, 
              method.args = list(start=c(Im=2e5))) +
  ggtitle(&quot;Shrubland&quot;)

grid.arrange(A,B, nrow = 1)</code></pre>
<p><img src="05_output_figures/scatterplot_abundance_glass_slides_with_measured_death_rate_by_ecosystem-1.png" width="672" /></p>
</div>
<div id="immigration-rate-calculations-assuming-equilibrium" class="section level1">
<h1>Immigration rate calculations assuming equilibrium</h1>
<p>Looking at the first graph of abundance on the glass slides above, it seems that, on and after the third time point, the abundance on the glass slides is at equilibrium. Actually, for the grassland, it looks like abundance dips a little, either driven by higher death rate or lower immigration rate, so we can just use the third timepoint to calculate our immigration rate at equilibrium.</p>
<pre class="r"><code># Calculate immigration rate for the grassland 
imm.grass &lt;- grass.cells %&gt;% filter(Treatment == &quot;Open&quot;, Time_Point %in% c(&quot;3&quot;)) %&gt;% 
  summarize(mean = mean(number_cells_on_glass_slide_cleaned)) * r.grass

print(paste0(&quot;The immigration rate for the grassland is &quot;, imm.grass, &quot; cells / day.&quot;))</code></pre>
<pre><code>[1] &quot;The immigration rate for the grassland is 20287.3196400304 cells / day.&quot;</code></pre>
<pre class="r"><code># Calculate immigration rate for the shrubland 
imm.shrub &lt;- shrub.cells %&gt;% filter(Treatment == &quot;Open&quot;, Time_Point %in% c(&quot;3&quot;)) %&gt;% 
  summarize(mean = mean(number_cells_on_glass_slide_cleaned)) * r.shrub

print(paste0(&quot;The immigration rate for the shrubland is &quot;, imm.shrub, &quot; cells / day.&quot;))</code></pre>
<pre><code>[1] &quot;The immigration rate for the shrubland is 10861.2794380827 cells / day.&quot;</code></pre>
</div>
<div id="death-rates-by-ecosystem" class="section level1">
<h1>Death rates by ecosystem</h1>
<p>One potentially interesting question is if death rates (for bacteria) differ by ecosystem. We can answer this question by running an ANCOVA on the abundance in the death slides, to see if there is an interaction between time and ecosystem.</p>
<pre class="r"><code>cell.counts.use %&gt;% filter(Treatment == &quot;Death&quot;) %&gt;% 
  mutate(log_abundance_minus_intercept = ifelse(Ecosystem == &quot;Shrubland&quot;, 
                                            log(number_cells_on_glass_slide_cleaned) - intercept.shrub, 
                              ifelse(Ecosystem == &quot;Grassland&quot;, 
                                     log(number_cells_on_glass_slide_cleaned) - intercept.grass, NA))) %&gt;% 
  lm(formula = log_abundance_minus_intercept ~ Time_as_days:Ecosystem + Time_as_days + 0, data = .) %&gt;% # independent of order
  Anova(type = &quot;II&quot;)</code></pre>
<pre><code>Anova Table (Type II tests)

Response: log_abundance_minus_intercept
                       Sum Sq Df  F value  Pr(&gt;F)    
Time_as_days           35.838  1 211.8550 &lt; 2e-16 ***
Time_as_days:Ecosystem  0.654  1   3.8689 0.05566 .  
Residuals               7.274 43                     
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code>cell.counts.use %&gt;% filter(Treatment == &quot;Death&quot;) %&gt;% 
  mutate(log_abundance_minus_intercept = ifelse(Ecosystem == &quot;Shrubland&quot;, 
                                            log(number_cells_on_glass_slide_cleaned) - intercept.shrub, 
                              ifelse(Ecosystem == &quot;Grassland&quot;, 
                                     log(number_cells_on_glass_slide_cleaned) - intercept.grass, NA))) %&gt;% 
  lm(formula = log_abundance_minus_intercept ~ Time_as_days:Ecosystem + 0, data = .) %&gt;% # independent of order
  Anova(type = &quot;II&quot;)</code></pre>
<pre><code>Anova Table (Type II tests)

Response: log_abundance_minus_intercept
                       Sum Sq Df F value    Pr(&gt;F)    
Time_as_days:Ecosystem 36.492  2  107.86 &lt; 2.2e-16 ***
Residuals               7.274 43                      
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
<div id="taxa-dying-at-different-rates" class="section level1">
<h1>Taxa dying at different rates?</h1>
<p>Another potentially interesting question is if taxa on the death rate slides die at different rates. We can answer this question by running PERMANOVA on the death rate samples to see if time influences either 16S or ITS composition.</p>
<pre class="r"><code># Load data
glass.slides.16S &lt;- &quot;03_Processed_data/16S_glass_slides.rda&quot;
load(glass.slides.16S)

# Create our visualization, just for fun
q1.NMDS1 &lt;- metaMDS(q1.bray.dist, autotransform = FALSE, k = 2)</code></pre>
<pre><code>Run 0 stress 0.184611 
Run 1 stress 0.1840205 
... New best solution
... Procrustes: rmse 0.01815191  max resid 0.1775647 
Run 2 stress 0.1954214 
Run 3 stress 0.1911713 
Run 4 stress 0.1967837 
Run 5 stress 0.1918709 
Run 6 stress 0.2013347 
Run 7 stress 0.1968445 
Run 8 stress 0.1988129 
Run 9 stress 0.1870468 
Run 10 stress 0.1892339 
Run 11 stress 0.1935835 
Run 12 stress 0.1896745 
Run 13 stress 0.2023892 
Run 14 stress 0.1878936 
Run 15 stress 0.190776 
Run 16 stress 0.1957297 
Run 17 stress 0.1910222 
Run 18 stress 0.1865509 
Run 19 stress 0.1854668 
Run 20 stress 0.1963026 
*** No convergence -- monoMDS stopping criteria:
    19: stress ratio &gt; sratmax
     1: scale factor of the gradient &lt; sfgrmin</code></pre>
<pre class="r"><code>q1.NMDS1.meta &lt;- data.frame(q1.NMDS1$points[,1:2]) %&gt;% 
  rownames_to_column(&quot;SampleID&quot;) %&gt;% 
  filter(grepl(&quot;LD&quot;, SampleID)) %&gt;% 
  mutate(TimePoint = str_match(SampleID, &quot;T([0-4])&quot;)[,2]) %&gt;% 
  mutate(Ecosystem = str_match(SampleID, &quot;R[0-9][A-C]?([GS])&quot;)[,2], 
         Ecosystem = ifelse(Ecosystem == &quot;G&quot;, &quot;Grassland&quot;, &quot;Shrubland&quot;)) %&gt;% 
  filter(!(SampleID == &quot;LDT0R5G_oops&quot;))

ggplot(data = q1.NMDS1.meta) +
  geom_point(aes(x = MDS1, y = MDS2, color = as.factor(TimePoint), shape = as.factor(Ecosystem)), size = 4) + 
  theme_classic() +
  scale_color_brewer(palette = &quot;Set1&quot;) </code></pre>
<p><img src="05_output_figures/NMDS_taxa_specific_death_rates_bacteria-1.png" width="672" /></p>
<pre class="r"><code># Do the PERMANOVA that will test our hypothesis
q1.bray.dist.df.death &lt;- as.data.frame(as.matrix(q1.bray.dist)) %&gt;% 
  rownames_to_column(&quot;SampleID&quot;) %&gt;% 
  filter(grepl(&quot;LD&quot;, SampleID)) %&gt;% 
  filter(!(SampleID == &quot;LDT0R5G_oops&quot;)) %&gt;% 
  mutate(SampleID = str_remove(SampleID, &quot;_dup_new_protocol&quot;)) %&gt;% 
  column_to_rownames(&quot;SampleID&quot;) %&gt;% 
  select(starts_with(&quot;LD&quot;)) %&gt;%
  select(!(&quot;LDT0R5G_oops&quot;)) %&gt;% 
  rename(LDT1R5BG = LDT1R5BG_dup_new_protocol)

      
adonis(q1.bray.dist.df.death ~ TimePoint, permutations = 10000, 
       data = q1.NMDS1.meta, na.rm= TRUE)</code></pre>
<pre><code>
Call:
adonis(formula = q1.bray.dist.df.death ~ TimePoint, data = q1.NMDS1.meta,      permutations = 10000, na.rm = TRUE) 

Permutation: free
Number of permutations: 10000

Terms added sequentially (first to last)

          Df SumsOfSqs MeanSqs F.Model      R2 Pr(&gt;F)    
TimePoint  4    2.3570 0.58925  2.1924 0.42223  2e-04 ***
Residuals 12    3.2252 0.26877         0.57777           
Total     16    5.5822                 1.00000           
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code>adonis(q1.bray.dist.df.death ~ TimePoint * as.factor(Ecosystem), permutations = 10000, 
       data = q1.NMDS1.meta, na.rm= TRUE)</code></pre>
<pre><code>
Call:
adonis(formula = q1.bray.dist.df.death ~ TimePoint * as.factor(Ecosystem),      data = q1.NMDS1.meta, permutations = 10000, na.rm = TRUE) 

Permutation: free
Number of permutations: 10000

Terms added sequentially (first to last)

                               Df SumsOfSqs MeanSqs F.Model      R2    Pr(&gt;F)
TimePoint                       4    2.3570 0.58925  3.3242 0.42223 9.999e-05
as.factor(Ecosystem)            1    0.8914 0.89136  5.0285 0.15968 9.999e-05
TimePoint:as.factor(Ecosystem)  1    0.5613 0.56128  3.1664 0.10055 9.999e-05
Residuals                      10    1.7726 0.17726         0.31754          
Total                          16    5.5822                 1.00000          
                                  
TimePoint                      ***
as.factor(Ecosystem)           ***
TimePoint:as.factor(Ecosystem) ***
Residuals                         
Total                             
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code># Load data
glass.slides.ITS &lt;- &quot;03_Processed_data/ITS_glass_slides.rda&quot;
load(glass.slides.ITS)

# Create our visualization, just for fun
q1.ITS.NMDS1 &lt;- metaMDS(q1.ITS.bray.dist, autotransform = FALSE, k = 2, trymax = 200)</code></pre>
<pre><code>Run 0 stress 0.1686672 
Run 1 stress 0.1748943 
Run 2 stress 0.1998142 
Run 3 stress 0.1733684 
Run 4 stress 0.1733534 
Run 5 stress 0.1741142 
Run 6 stress 0.176396 
Run 7 stress 0.1706314 
Run 8 stress 0.2093767 
Run 9 stress 0.1757716 
Run 10 stress 0.177819 
Run 11 stress 0.1707782 
Run 12 stress 0.1731314 
Run 13 stress 0.1758703 
Run 14 stress 0.4136501 
Run 15 stress 0.1706246 
Run 16 stress 0.2044783 
Run 17 stress 0.1772174 
Run 18 stress 0.1768273 
Run 19 stress 0.1686674 
... Procrustes: rmse 0.0004288042  max resid 0.004413662 
... Similar to previous best
Run 20 stress 0.1742231 
*** Solution reached</code></pre>
<pre class="r"><code>q1.ITS.NMDS1.meta &lt;- data.frame(q1.ITS.NMDS1$points[,1:2]) %&gt;% 
  rownames_to_column(&quot;SampleID&quot;) %&gt;% 
  filter(grepl(&quot;LD&quot;, SampleID)) %&gt;% 
  mutate(TimePoint = str_match(SampleID, &quot;T([0-4])&quot;)[,2]) %&gt;% 
  mutate(Ecosystem = str_match(SampleID, &quot;R[0-9][A-C]?([GS])&quot;)[,2], 
         Ecosystem = ifelse(Ecosystem == &quot;G&quot;, &quot;Grassland&quot;, &quot;Shrubland&quot;)) %&gt;% 
  filter(!(SampleID == &quot;LDT0R5G_oops&quot;))

ggplot(data = q1.ITS.NMDS1.meta) +
  geom_point(aes(x = MDS1, y = MDS2, color = as.factor(TimePoint), shape = as.factor(Ecosystem)), size = 4) + 
  theme_classic() +
  scale_color_brewer(palette = &quot;Set1&quot;) </code></pre>
<p><img src="05_output_figures/NMDS_taxa_specific_death_rates_fungi-1.png" width="672" /></p>
<pre class="r"><code># Do the PERMANOVA that will test our hypothesis
q1.bray.dist.df.death &lt;- q1.ITS.bray.dist.df %&gt;% 
  rownames_to_column(&quot;SampleID&quot;) %&gt;% 
  filter(grepl(&quot;LD&quot;, SampleID)) %&gt;% 
  column_to_rownames(&quot;SampleID&quot;) %&gt;% 
  select(starts_with(&quot;LD&quot;))


adonis(q1.bray.dist.df.death ~ TimePoint, permutations = 10000, 
       data = q1.ITS.NMDS1.meta, na.rm= TRUE)</code></pre>
<pre><code>
Call:
adonis(formula = q1.bray.dist.df.death ~ TimePoint, data = q1.ITS.NMDS1.meta,      permutations = 10000, na.rm = TRUE) 

Permutation: free
Number of permutations: 10000

Terms added sequentially (first to last)

          Df SumsOfSqs MeanSqs F.Model      R2 Pr(&gt;F)
TimePoint  2    0.5367 0.26835  1.1419 0.17192 0.2544
Residuals 11    2.5851 0.23501         0.82808       
Total     13    3.1218                 1.00000       </code></pre>
<pre class="r"><code>adonis(q1.bray.dist.df.death ~ TimePoint * as.factor(Ecosystem), permutations = 10000, 
       data = q1.ITS.NMDS1.meta, na.rm= TRUE)</code></pre>
<pre><code>
Call:
adonis(formula = q1.bray.dist.df.death ~ TimePoint * as.factor(Ecosystem),      data = q1.ITS.NMDS1.meta, permutations = 10000, na.rm = TRUE) 

Permutation: free
Number of permutations: 10000

Terms added sequentially (first to last)

                               Df SumsOfSqs MeanSqs F.Model      R2    Pr(&gt;F)
TimePoint                       2   0.53670 0.26835  2.1840 0.17192    0.0177
as.factor(Ecosystem)            1   1.27000 1.27000 10.3360 0.40682 9.999e-05
TimePoint:as.factor(Ecosystem)  1   0.20922 0.20922  1.7027 0.06702    0.1081
Residuals                       9   1.10584 0.12287         0.35424          
Total                          13   3.12176                 1.00000          
                                  
TimePoint                      *  
as.factor(Ecosystem)           ***
TimePoint:as.factor(Ecosystem)    
Residuals                         
Total                             
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
<div id="dispersal-communities-by-ecosystem" class="section level1">
<h1>Dispersal communities by ecosystem</h1>
<p>A key question of this study is - Do different ecosystems (plant communities) have different dispersal communities? To answer this question, we will use a PERMANOVA to see if different ecosystems show different bacterial and fungal communities on the glass slides.</p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("hide" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
