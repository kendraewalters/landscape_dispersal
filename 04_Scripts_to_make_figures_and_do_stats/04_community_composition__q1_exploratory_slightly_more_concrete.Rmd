---
title: "Glass Slides Data Exploration â€” Chapter 3"
author: "Kendra Walters"
date: "11/11/2020"
output: 
  html_document:
    toc: yes
    toc_float: TRUE
    code_folding: hide
---

```{r setup, include=FALSE}
library(knitr)
library(data.table)
library(vegan)
library(ggplot2)
library(dplyr)
library(ncf)
library(tidyverse)
opts_knit$set(root.dir = "/Users/walters_kendra/Google\ Drive/Dispersal_Ch_3/02_Data/06_Community_Composition/06_Output_from_qiime/")
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, comment = "")

```

# Hello from glass slides! 

This page gives the most promising exploratory graphs/stats from the Landscape Dispersal project. 

First off, we are answering our *first* question in our project - 

### Do different ecosystems (plant communities) have different dispersal communities?

Check it out below, but the answer is YES!! There are DEFINITELY different taxa dispersing in the grassland than the shrubland. 

```{r bacterial - by ecosystem, echo = FALSE}
nmds_plus_metadata <- fread("Q1_single_16S/metadata_for_PRIMER_because_stupid_sample_order_q1_single_r971.txt", data.table = FALSE)

bc.median <- as.data.frame(fread("Q1_single_16S/BC_median__r971_single.tsv"))
row.names(bc.median) <- bc.median$V1
bc.median$V1 <- NULL

# Keep only the open slides
bc.dispersal <- bc.median[grepl("^LO", row.names(bc.median)),
                          grepl("^LO", colnames(bc.median))]

just_dispersal <- nmds_plus_metadata[nmds_plus_metadata$Treatment == "Open", ]
just_dispersal <- just_dispersal[!(is.na(just_dispersal$Row.names)), ]

tmp <- as.dist(as.matrix(bc.dispersal))

ggplot(data = just_dispersal) +
  geom_point(aes(x = MDS1, y = MDS2, color = Ecosystem), size = 4) + 
  labs(col =  "Ecosystem") +
  theme_classic() +
  scale_color_brewer(palette = "Set1") 


adonis(tmp ~ Ecosystem, data = just_dispersal)
anova(betadisper(tmp, just_dispersal$Ecosystem))

```

### Second, how far are microorganisms dispersing?

This gives us a sense of the dispersal kernal. We hypothesize that samples closer together (but still across the ecosystem boundary) have more similar dispersal communities than samples farther apart. However, as you can see, this relatively easy analysis does not support that hypothesis, likely because the analysis method here reduces the sample size by only comparing every sample to one other sample.

```{r dispersal kernal, echo=FALSE}

bc <- as.data.frame(fread("~/Google Drive/Dispersal_Ch_3/02_Data/06_Community_Composition/06_Output_from_qiime/Q1_single_16S/BC_median__r971_single.tsv"))
row.names(bc) <- bc$V1
bc$V1 <- NULL

dist.df <- data.frame("Distance" = c(rep(1, 12), rep(3, 12), rep(7, 12), rep(15, 12)), 
                      "Time Point" = c(rep(c("T1", "T1", "T1", "T2", "T2", "T2", "T3", "T3", "T3", "T4", "T4",  "T4"), 4)), 
                      "Transect" = c(rep(c("A", "B", "C"), 16)))

dist.df$tmp_1 <- recode(dist.df$Distance, `1` = 4, `3` = 3, `7` = 2, `15` = 1)
dist.df$tmp_2 <- recode(dist.df$Distance, `1` = 5, `3` = 6, `7` = 7, `15` = 8)
dist.df$Sample_1 <- paste0("LO", dist.df$Time.Point, dist.df$Transect, dist.df$tmp_1)
dist.df$Sample_2 <- paste0("LO", dist.df$Time.Point, dist.df$Transect, dist.df$tmp_2)

dist.df$tmp_1 <- NULL
dist.df$tmp_2 <- NULL

distance <- list()
sample.1.is <- list()
sample.2.is <- list()

for (i in 1:nrow(dist.df)) {
  sample.1 <- dist.df[i, c("Sample_1")]
  sample.1.is[[i]] <- sample.1 %in% names(bc)
  sample.2 <- dist.df[i, c("Sample_2")]
  sample.2.is[[i]] <- sample.2 %in% names(bc)
  
  distance[[i]] <- bc[sample.1, sample.2]
  
}

dist.df$Sample_1_IS <- sample.1.is
dist.df$Sample_2_IS <- sample.2.is

dist.df$Comm_Distance <- distance


dist.df <- dist.df[!(is.null(dist.df$Comm_Distance)), ]
ggplot() + geom_point(data = dist.df, aes(x = Distance, y = as.numeric(as.character(Comm_Distance)))) + geom_smooth(data = dist.df, aes(x = Distance, y = as.numeric(as.character(Comm_Distance))), method = "lm") +
  theme_classic() + 
  xlab("Meters") + ylab("Bray-Curtis Dissimilarity")

summary(lm(as.numeric(as.character(Comm_Distance)) ~ Distance, dist.df))


```


The next option is to try a partial mantel test because, what we want to test, is if geographic distance and community dissimilarity are correlated when differences (variation) caused by different ecosystems is taken out. We can also graph geographic distance v community dissimilarity for pairwise samples from different ecosystems to see if there is a recognizable dispersal kernel. We just can't run a regression on those pairwise samples because the samples are not independent from one another. 

First we will look at that dot plot graph to see if there is any recognizable dispersal kernel. Then the partial mantel test. 


``` {r dispersal kernel complicated, echo = FALSE}

## Load and clean up the BC matrix
bc <- as.data.frame(fread("Q1_single_16S/BC_median__r971_single.tsv"))
row.names(bc) <- bc$V1
bc$V1 <- NULL

bc <- bc[grepl(pattern = "[A-C][1-8]", row.names(bc)), grepl("[A-C][1-8]", names(bc))] # keep only glass slide dispersal samples
bc.dist <- as.dist(as.matrix(bc))

## Load site coordinates and use to make dataframe of coordinates for each sample
site.coords <- as.data.frame(fread("./../../site_locs_coordinates.tsv"))

sample.coords <- data.frame("Sample" = row.names(bc))
sample.coords$Site <- str_extract(sample.coords$Sample, "[ABC][1-8]")
sample.coords <- sample.coords[!(is.na(sample.coords$Site)), ]

sample.coords <- merge(sample.coords, site.coords, by.x = "Site", by.y = "V1")

## Make euclidean distance matrix for each sample
row.names(sample.coords) <- sample.coords$Sample
sample.coords$Sample <- NULL
sample.coords$Site <- NULL
sample.coords <- sample.coords[rownames(bc), ] # reorder to match order of BC matrix

sample.euc <- dist(sample.coords, method = "euclidean")
sample.euc.df <- as.data.frame(as.matrix(sample.euc))


## First, make a plot of geo distance v comm distance
plot(sample.euc, bc.dist)

sample.euc.bt <- 

buey <- data.frame("Euc" = as.vector(as.matrix(sample.euc)), "BC" = as.vector(as.matrix(bc.dist)))
buey <- buey[!(buey$Euc == 0 & buey$BC == 0), ]

ggplot(buey, aes(x = Euc, y = BC)) + geom_point() + geom_smooth() # not looking too promising but lets forge ahead


## Now, to do the partial mantel, we need to make our model matrix for ecosystem type
eco <- data.frame(row.names = row.names(sample.coords))
eco$Ecosystem <- ifelse(grepl("[A-C][1-4]", rownames(eco)), 1, 2)

eco.dist <- dist(eco)
eco.dist.df <- as.data.frame(as.matrix(eco.dist))

## Partial mantel test time, baaaaby
partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000)
# partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000, method = "spearman")
# partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000, method = "kendall")


```
The partial mantel test shows that our hypothesis is NOT supported. It demonstrates that there is no significant correlation between community dissimilarity and geographic distance (P = 0.096), even if differences in ecosystem are controlled for (P = 0.24). However, this test shows us, like the PERMANOVA above, that community dissimilarity and ecosystem type are significantly correlated (P = 0.0020; r = 0.123) and, more importantly, are still correlated when geographic distance is controlled for (P = 0.0020, r = 0.112). This tells us that our relationship between ecosystem and dispersal community is not just an effect of spatial autocorrelation. The partial mantel test also tells us that geographic distance and ecosystem type are significantly related (P = 0.0020; r = 0.241), although that result isn't interesting since its just analyzing our experimental design and no data. 

I've reported here the partial mantel test with the spearman correlation, but the same trends were found using the pearson and kendall method. 


All of these tests show us that the dispersal kernel is likely really small, since we aren't picking up any relationship between geographic distance and dispersal community. 

### Testing the influence of surrounding plant composition
Piggybacking on analyzing dispersal kernels, we are going to test the correlation between the plant communities and/or geographic distance and dispersal communities. Because we previously discovered that geographic distance and dispersal communities do not have a significant relationship, this strengthens my hypothesis that - plant communities will have a stronger correlation to dispersal communities than geographic distance. 

```{r plants 1 m, echo = FALSE}
## Load and clean up the BC matrix
bc <- as.data.frame(fread("Q1_single_16S/BC_median__r971_single.tsv"))
row.names(bc) <- bc$V1
bc$V1 <- NULL

bc <- bc[grepl(pattern = "[A-C][1-8]", row.names(bc)), grepl("[A-C][1-8]", names(bc))] # keep only glass slide dispersal samples

## Load site coordinates and use to make dataframe of coordinates for each sample
site.coords <- as.data.frame(fread("./../../site_locs_coordinates.tsv"))

sample.coords <- data.frame("Sample" = row.names(bc))
sample.coords$Site <- str_extract(sample.coords$Sample, "[ABC][1-8]")
sample.coords <- merge(sample.coords, site.coords, by.x = "Site", by.y = "V1")

## Make euclidean distance matrix for each sample
row.names(sample.coords) <- sample.coords$Sample
sample.coords$Sample <- NULL
sample.coords$Site <- NULL
sample.coords <- sample.coords[rownames(bc), ] # reorder to match order of BC matrix

sample.euc <- dist(sample.coords, method = "euclidean")


## reading in plant composition bc and make df of plant composition of each sample
plants <- fread("grass_shrub_1_meter_composition_df.tsv", data.table = FALSE)

sample.plants <- data.frame("Sample" = row.names(bc))
sample.plants$Site <- str_extract(sample.plants$Sample, "[ABC][1-8]")
sample.plants <- merge(sample.plants, plants, by.x = "Site", by.y = "V1")

## Make bc distance matrix of plants for each sample
row.names(sample.plants) <- sample.plants$Sample
sample.plants$Sample <- NULL
sample.plants$Site <- NULL
sample.plants <- sample.plants[rownames(bc), ] # reorder to match order of BC matrix

sample.plants.bc <- vegdist(sample.plants)

## Partial mantel test time, baaaaby
partial.mantel.test(as.matrix(bc), as.matrix(sample.euc), as.matrix(sample.plants.bc), resamp = 1000)
# partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000, method = "spearman")
# partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000, method = "kendall")



```

### Next, we can basically repeat the whole shebang with FUNGI
```{r fungi - by ecosystem, echo = FALSE}
# Read in BC matrix
bc.median <- as.data.frame(fread("Q1_single_ITS/BC_median_ITS__r2000_single.tsv"))
row.names(bc.median) <- bc.median$V1
bc.median$V1 <- NULL

# Select only the open glass slides
bc.dispersal <- bc.median[grepl("^LO", row.names(bc.median)),
                          grepl("^LO", colnames(bc.median))]

#Next, we will run an NMDS, which is a form of ordination and can be used to visualize beta diversity.
NMDS1 <- metaMDS(bc.dispersal, autotransform = FALSE, k = 2)

#This will make the first two columns as the x and y coordinates, so that they may be plotted.
coordinates <- data.frame(NMDS1$points[,1:2])
coordinates$Sample <- row.names(coordinates)

# Create the metadata
metadata <- data.frame("Sample" = row.names(bc.dispersal))
metadata <- metadata %>% filter(grepl("LO", Sample))
metadata$Ecosystem <- ifelse(grepl(pattern = "[ABC][1-4]", metadata$Sample), "Shrubland", "Grassland")

# Merge the two
bc.fungi.meta <- merge(coordinates, metadata, by = "Sample")

# Plot the data
ggplot(data = bc.fungi.meta) +
  geom_point(aes(x = MDS1, y = MDS2, color = Ecosystem), size = 4) + 
  labs(col =  "Ecosystem") +
  theme_classic() +
  scale_color_brewer(palette = "Set1") 

# And the test
tmp <- as.dist(as.matrix(bc.dispersal))

adonis(tmp ~ Ecosystem, data = bc.fungi.meta)
anova(betadisper(tmp, bc.fungi.meta$Ecosystem))
betadisper(tmp, bc.fungi.meta$Ecosystem)
```

```{r dispersal kernal fungi, echo=FALSE}

bc <- as.data.frame(fread("~/Google Drive/Dispersal_Ch_3/02_Data/06_Community_Composition/06_Output_from_qiime/Q1_single_ITS/BC_median_ITS__r2000_single.tsv"))
row.names(bc) <- bc$V1
bc$V1 <- NULL

dist.df <- data.frame("Distance" = c(rep(1, 12), rep(3, 12), rep(7, 12), rep(15, 12)), 
                      "Time Point" = c(rep(c("T1", "T1", "T1", "T2", "T2", "T2", "T3", "T3", "T3", "T4", "T4",  "T4"), 4)), 
                      "Transect" = c(rep(c("A", "B", "C"), 16)))

dist.df$tmp_1 <- recode(dist.df$Distance, `1` = 4, `3` = 3, `7` = 2, `15` = 1)
dist.df$tmp_2 <- recode(dist.df$Distance, `1` = 5, `3` = 6, `7` = 7, `15` = 8)
dist.df$Sample_1 <- paste0("LO", dist.df$Time.Point, dist.df$Transect, dist.df$tmp_1)
dist.df$Sample_2 <- paste0("LO", dist.df$Time.Point, dist.df$Transect, dist.df$tmp_2)

dist.df$tmp_1 <- NULL
dist.df$tmp_2 <- NULL

distance <- list()
sample.1.is <- list()
sample.2.is <- list()

for (i in 1:nrow(dist.df)) {
  sample.1 <- dist.df[i, c("Sample_1")]
  sample.1.is[[i]] <- sample.1 %in% names(bc)
  sample.2 <- dist.df[i, c("Sample_2")]
  sample.2.is[[i]] <- sample.2 %in% names(bc)
  
  distance[[i]] <- bc[sample.1, sample.2]
  
}

dist.df$Sample_1_IS <- sample.1.is
dist.df$Sample_2_IS <- sample.2.is

dist.df$Comm_Distance <- distance


dist.df <- dist.df[!(is.null(dist.df$Comm_Distance)), ]
ggplot() + geom_point(data = dist.df, aes(x = Distance, y = as.numeric(as.character(Comm_Distance)))) + geom_smooth(data = dist.df, aes(x = Distance, y = as.numeric(as.character(Comm_Distance))), method = "lm") +
  theme_classic() + 
  xlab("Meters") + 
  ylab("Bray-Curtis Dissimilarity")

summary(lm(as.numeric(as.character(Comm_Distance)) ~ Distance, dist.df))

```


``` {r dispersal kernel complicated, echo = FALSE}

## Load and clean up the BC matrix
bc <- as.data.frame(fread("~/Google Drive/Dispersal_Ch_3/02_Data/06_Community_Composition/06_Output_from_qiime/Q1_single_ITS/BC_median_ITS__r2000_single.tsv"))
row.names(bc) <- bc$V1
bc$V1 <- NULL

bc <- bc[grepl(pattern = "[A-C][1-8]", row.names(bc)), grepl("[A-C][1-8]", names(bc))] # keep only glass slide dispersal samples
bc.dist <- as.dist(as.matrix(bc))

## Load site coordinates and use to make dataframe of coordinates for each sample
site.coords <- as.data.frame(fread("./../../site_locs_coordinates.tsv"))

sample.coords <- data.frame("Sample" = row.names(bc))
sample.coords$Site <- str_extract(sample.coords$Sample, "[ABC][1-8]")
sample.coords <- sample.coords[!(is.na(sample.coords$Site)), ]

sample.coords <- merge(sample.coords, site.coords, by.x = "Site", by.y = "V1")

## Make euclidean distance matrix for each sample
row.names(sample.coords) <- sample.coords$Sample
sample.coords$Sample <- NULL
sample.coords$Site <- NULL
sample.coords <- sample.coords[rownames(bc), ] # reorder to match order of BC matrix

sample.euc <- dist(sample.coords, method = "euclidean")
sample.euc.df <- as.data.frame(as.matrix(sample.euc))


## First, make a plot of geo distance v comm distance
plot(sample.euc, bc.dist)

buey <- data.frame("Euc" = as.vector(as.matrix(sample.euc)), "BC" = as.vector(as.matrix(bc.dist)))
buey <- buey[!(buey$Euc == 0 & buey$BC == 0), ]

ggplot(buey, aes(x = Euc, y = BC)) + geom_point() + geom_smooth(method = "lm") +
  xlab("Geographic Distance") + ylab("Community Dissimilarity") + 
  theme_classic()
# looks great, better than bacteria


## Now, to do the partial mantel, we need to make our model matrix for ecosystem type
eco <- data.frame(row.names = row.names(sample.coords))
eco$Ecosystem <- ifelse(grepl("[A-C][1-4]", rownames(eco)), 1, 2)

eco.dist <- dist(eco)
eco.dist.df <- as.data.frame(as.matrix(eco.dist))

## Partial mantel test time, baaaaby
partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000)
# partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000, method = "spearman")
# partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000, method = "kendall")
```


```{r plants 1 m, echo = FALSE}
## Load and clean up the BC matrix
bc <- as.data.frame(fread("Q1_single_ITS/BC_median_ITS__r2000_single.tsv"))
row.names(bc) <- bc$V1
bc$V1 <- NULL

bc <- bc[grepl(pattern = "[A-C][1-8]", row.names(bc)), grepl("[A-C][1-8]", names(bc))] # keep only glass slide dispersal samples

## Load site coordinates and use to make dataframe of coordinates for each sample
site.coords <- as.data.frame(fread("./../../site_locs_coordinates.tsv"))

sample.coords <- data.frame("Sample" = row.names(bc))
sample.coords$Site <- str_extract(sample.coords$Sample, "[ABC][1-8]")
sample.coords <- merge(sample.coords, site.coords, by.x = "Site", by.y = "V1")

## Make euclidean distance matrix for each sample
row.names(sample.coords) <- sample.coords$Sample
sample.coords$Sample <- NULL
sample.coords$Site <- NULL
sample.coords <- sample.coords[rownames(bc), ] # reorder to match order of BC matrix

sample.euc <- dist(sample.coords, method = "euclidean")


## reading in plant composition bc and make df of plant composition of each sample
plants <- fread("grass_shrub_1_meter_composition_df.tsv", data.table = FALSE)

sample.plants <- data.frame("Sample" = row.names(bc))
sample.plants$Site <- str_extract(sample.plants$Sample, "[ABC][1-8]")
sample.plants <- merge(sample.plants, plants, by.x = "Site", by.y = "V1")

## Make bc distance matrix of plants for each sample
row.names(sample.plants) <- sample.plants$Sample
sample.plants$Sample <- NULL
sample.plants$Site <- NULL
sample.plants <- sample.plants[rownames(bc), ] # reorder to match order of BC matrix

sample.plants.bc <- vegdist(sample.plants)

## Partial mantel test time, baaaaby
partial.mantel.test(as.matrix(bc), as.matrix(sample.euc), as.matrix(sample.plants.bc), resamp = 1000)
# partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000, method = "spearman")
# partial.mantel.test(as.matrix(bc.dist), as.matrix(sample.euc), as.matrix(eco.dist), resamp = 1000, method = "kendall")



```

The spatial autocorrelation of fungi is ONLY due to the spatial autocorrelation of plants. DUmmdummmdum  ....


### Within each time point

### Within each ecosystem



